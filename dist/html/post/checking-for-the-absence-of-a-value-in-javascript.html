<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-124182818-1"></script>
        <script>
            window.dataLayer = window.dataLayer || []
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'UA-124182818-1');
        </script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">

        <title>Tomer Aberbach | Checking for the Absence of a Value in JavaScript</title>

        <meta name="author" content="Tomer Aberbach">
        <meta name="creator" content="Tomer Aberbach">
        <meta name="description" content="A thorough overview of the right way to check for the absence of a value in JavaScript.">
        <meta name="keywords" content="code,computer science,explainer,javascript,mathematics,nodejs,portfolio,programming,read,resume">

        <meta itemprop="name" content="Tomer Aberbach | Checking for the Absence of a Value in JavaScript">
        <meta itemprop="description" content="A thorough overview of the right way to check for the absence of a value in JavaScript.">
        <meta itemprop="image" content="https://tomeraberba.ch/img/icon.png">

        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:site" content="@TomerAberbach">
        <meta name="twitter:title" content="Tomer Aberbach | Checking for the Absence of a Value in JavaScript">
        <meta name="twitter:description" content="A thorough overview of the right way to check for the absence of a value in JavaScript.">
        <meta name="twitter:creator" content="@TomerAberbach">
        <meta name="twitter:image" content="https://tomeraberba.ch/img/icon.png">
        <meta name="twitter:image:src" content="https://tomeraberba.ch/img/icon.png">

        <meta property="og:title" content="Tomer Aberbach | Checking for the Absence of a Value in JavaScript">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://tomeraberba.ch/html/post/checking-for-the-absence-of-a-value-in-javascript.html">
        <meta property="og:image" content="https://tomeraberba.ch/img/icon.png">
        <meta property="og:description" content="A thorough overview of the right way to check for the absence of a value in JavaScript.">
        <meta property="og:site_name" content="Tomer Aberbach | Checking for the Absence of a Value in JavaScript">

        <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/favicon/mstile-144x144.png">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

                <link rel="stylesheet" href="../../css/all.css">
                <link rel="stylesheet" href="../../css/post.css">
    </head>
    <body>
        <header id="site-header">
            <h1>
                <a href="../../index.html">
                    tomer aberbach
                </a>
            </h1>

                <a href="mailto:tomeraberbach@gmail.com" target="_blank" rel="noopener">
                    <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M9.732 8.485l4.95 4.242a1.01 1.01 0 01-.689.273H2.007a1.01 1.01 0 01-.69-.27l4.951-4.245L8 10zM8 9L1.318 3.273A1.01 1.01 0 012.007 3h11.986c.268 0 .51.103.69.27zm7 3.186l-4.833-4.107L15 3.875v8.31zm-14 0V3.878l4.833 4.2L1 12.187zm0 0"/></svg>
                </a>
                <a href="https://github.com/TomerAberbach" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
                </a>
                <a href="https://www.npmjs.com/~tomeraberbach" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>NPM</title><path d="M0 7.334v8h6.666v1.332H12v-1.332h12v-8H0zm6.666 6.664H5.334v-4H3.999v4H1.335V8.667h5.331v5.331zm4 0v1.336H8.001V8.667h5.334v5.332h-2.669v-.001zm12.001 0h-1.33v-4h-1.336v4h-1.335v-4h-1.33v4h-2.671V8.667h8.002v5.331z"/><path d="M10.665 10H12v2.667h-1.335V10z"/></svg>
                </a>
                <a href="https://www.linkedin.com/in/tomer-a" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
                </a>
                <a href="https://stackoverflow.com/users/story/5195839" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Stack Overflow</title><path d="M18.986 21.865v-6.404h2.134V24H1.844v-8.539h2.13v6.404h15.012zM6.111 19.731H16.85v-2.137H6.111v2.137zm.259-4.852l10.48 2.189.451-2.07-10.478-2.187-.453 2.068zm1.359-5.056l9.705 4.53.903-1.95-9.706-4.53-.902 1.936v.014zm2.715-4.785l8.217 6.855 1.359-1.62-8.216-6.853-1.35 1.617-.01.001zM15.751 0l-1.746 1.294 6.405 8.604 1.746-1.294L15.749 0h.002z"/></svg>
                </a>
                <a href="https://www.redbubble.com/people/tomeraberbach" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Redbubble</title><path d="M16.633 16.324h-3.199a.321.321 0 01-.32-.322V7.974a.32.32 0 01.32-.32H16.4c2.226 0 2.693 1.31 2.693 2.408 0 .636-.169 1.14-.504 1.511.816.337 1.256 1.096 1.256 2.194 0 1.601-1.201 2.557-3.212 2.557m-4.644 0H5.345a.32.32 0 01-.32-.322V7.974a.32.32 0 01.32-.32h3.103c1.939 0 3.096 1.043 3.096 2.791 0 1.163-.585 2.077-1.527 2.448l2.21 2.897a.322.322 0 01-.24.533M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12c6.628 0 12-5.373 12-12S18.63 0 12.001 0"/></svg>
                </a>
        </header>

        <main>
            <article>
    <h1>Checking for the Absence of a Value in JavaScript</h1>

    <ul class="tags-ul">
            <li>
                <a href="../tag/code/1.html">code</a>
            </li>
            <li>
                <a href="../tag/explainer/1.html">explainer</a>
            </li>
            <li>
                <a href="../tag/javascript/1.html">javascript</a>
            </li>
            <li>
                <a href="../tag/nodejs/1.html">nodejs</a>
            </li>
            <li>
                <a href="../tag/read/1.html">read</a>
            </li>
    </ul>

    <ul class="links-ul">
    </ul>

    <p>When I first started learning JavaScript I was confused by the seemingly endless ways developers check for the absence of a value:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(value == <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(value == <span class="hljs-literal">undefined</span>)
<span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">undefined</span>)
<span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">undefined</span> || value === <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value == <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> || value == <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(!value)
</code></pre>
<p>Which one is right?</p>
<h2 id="the-absence-of-a-value">The Absence of a Value <a class="header-anchor" href="#the-absence-of-a-value" aria-hidden="true">¶</a></h2>
<p>In order to understand which of these expressions is correct we must first take a look at the two ways JavaScript represents the lack of a value.</p>
<h3 id="undefined">Undefined <a class="header-anchor" href="#undefined" aria-hidden="true">¶</a></h3>
<p><code>undefined</code> is one of JavaScript’s primitive types which means checking its type using the <code>typeof</code> operator returns the string <code>'undefined'</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// undefined</span>
</code></pre>
<p>It is the default value of any declared, but unassigned variable:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> x
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// undefined</span>
</code></pre>
<p>It is the value returned when trying to access an undeclared object property:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.a) <span class="hljs-comment">// undefined</span>
</code></pre>
<p>It is the default return value of a function which does not return:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-built_in">console</span>.log(f()) <span class="hljs-comment">// undefined</span>
</code></pre>
<p>It is returned by the <code>void</code> operator, an operator which evaluates an expression and then returns <code>undefined</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">void</span> <span class="hljs-string">'hello'</span>) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">void</span>(<span class="hljs-number">3</span> + <span class="hljs-number">2</span>)) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">void</span>(<span class="hljs-comment">/* any expression */</span>)) <span class="hljs-comment">// undefined</span>
</code></pre>
<p>And lastly, it is not a literal. It is a property of the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object" class="external-a" target="_blank" rel="noopener">global object</a>, an object that always exists in the global scope (accessible through the <code>window</code> property on browsers).</p>
<h3 id="null">Null <a class="header-anchor" href="#null" aria-hidden="true">¶</a></h3>
<p><code>null</code> is also a JavaScript primitive type, but checking its type using the <code>typeof</code> operator does not return what you’d expect:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>) <span class="hljs-comment">// object</span>
</code></pre>
<p>According to <a href="https://www.w3schools.com/js/js_datatypes.asp" class="external-a" target="_blank" rel="noopener">W3Schools</a> you can consider this behavior a bug in JavaScript. <code>typeof null</code> should return <code>'null'</code>, but since a lot of code has already been written with the assumption that <code>typeof null</code> erroneously returns <code>'object'</code>, it will not be changed to avoid breaking old code.</p>
<p>Unlike <code>undefined</code>, <code>null</code> does not show up as a default value anywhere. Instead it is usually returned by functions which are expected to return an object when one could not be retrieved from the given parameters.</p>
<p>For example, in browsers <code>document.getElementById</code> returns <code>null</code> if no element with the given ID was found in the HTML document:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'some-id-which-no-element-has'</span>)) <span class="hljs-comment">// null</span>
</code></pre>
<p>In contrast to <code>undefined</code>, <code>null</code> <em>is</em> a literal. It is not the identifier of some property. It represents a lack of identification.</p>
<p>Based on these characteristics it is safe to say that both <code>undefined</code> and <code>null</code> represent the absence of a value. Therefore, any code we write which aims to check for the absence of a value should account for both <code>undefined</code> and <code>null</code>.</p>
<h2 id="equality">Equality <a class="header-anchor" href="#equality" aria-hidden="true">¶</a></h2>
<p>Now that we understand <code>undefined</code> and <code>null</code>, we still need to briefly address the difference between <code>==</code> and <code>===</code> in order to understand the expressions at the beginning of this post.</p>
<h3 id="strict">Strict <a class="header-anchor" href="#strict" aria-hidden="true">¶</a></h3>
<p>Strict equality is invoked using <code>===</code> and is relatively straight forward. If two values, <code>a</code> and <code>b</code>, are of different types then <code>a === b</code> will return <code>false</code>. However, if they are of the same type then <code>true</code> is returned if their contents match and <code>false</code> otherwise:</p>
<p>Examples:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> === <span class="hljs-number">0</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello!'</span> === <span class="hljs-string">'hello!'</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> === <span class="hljs-number">5</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> === <span class="hljs-string">'0'</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> === <span class="hljs-string">'hello!'</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>

<span class="hljs-keyword">var</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj === {}) <span class="hljs-comment">// false (because objects are compared by reference)</span>
<span class="hljs-built_in">console</span>.log(obj === obj) <span class="hljs-comment">// true (because reference to same object)</span>
</code></pre>
<h3 id="loose">Loose <a class="header-anchor" href="#loose" aria-hidden="true">¶</a></h3>
<p>Loose quality is invoked using <code>==</code> and often produces unexpected results. If two values, <code>a</code> and <code>b</code>, are of the same type then <code>a === b</code> is returned. However, if they are of different types then JavaScript will attempt to coerce (i.e. convert) the two values to the same type and then strictly equate the two. This second case has prompted the use of loose equality to be largely discouraged by the JavaScript community:</p>
<p>Examples:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-string">'1'</span>) <span class="hljs-comment">// true (because the string was converted to a number)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">// true (because the string was converted to a number)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> == <span class="hljs-literal">false</span>) <span class="hljs-comment">// true (because the boolean was converted to a number)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> == <span class="hljs-literal">null</span>) <span class="hljs-comment">// false (because absence of a value is never considered equal to a concrete value)</span>
<span class="hljs-built_in">console</span>.log({} == {}) <span class="hljs-comment">// false (because objects are compared by reference)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false (because absence of a value is never considered equal to a concrete value)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true (because both represent the absence of a value)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>) <span class="hljs-comment">// true (because both represent the absence of a value)</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello!"</span> == <span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">""</span> == <span class="hljs-literal">false</span>) <span class="hljs-comment">// true (because the string was converted to a boolean and an empty string kind of represents falsity in the realm of strings I guess?)</span>
<span class="hljs-built_in">console</span>.log([] == <span class="hljs-literal">false</span>) <span class="hljs-comment">// true (because the array was converted to a boolean and an empty array kind of represents falsity in the realm of array I guess?)</span>
</code></pre>
<p>If you’re feeling confused you wouldn’t be the only one. Check out this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using" class="external-a" target="_blank" rel="noopener">operand conversion table</a> and this <a href="https://www.sitepoint.com/javascript-truthy-falsy" class="external-a" target="_blank" rel="noopener">article</a> about truthy and falsey values if you want to fully understand loose equality. Additionally, if you want a handy reference of how <code>==</code> and <code>===</code> behave then I would recommend this <a href="https://dorey.github.io/JavaScript-Equality-Table/unified" class="external-a" target="_blank" rel="noopener">link</a>.</p>
<h2 id="bringing-it-all-together">Bringing It All Together <a class="header-anchor" href="#bringing-it-all-together" aria-hidden="true">¶</a></h2>
<p>It’s time to check which of the expressions from the beginning of the post work! Let’s take a look at the first expression and write a checklist to evaluate it:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(value == <span class="hljs-literal">null</span>)
</code></pre>
<ul>
<li><em>Does it return <code>true</code> on <code>undefined</code>?</em> Yes, because substituting <code>undefined</code> for <code>value</code> yields <code>undefined == null</code> and as we have learned from the loose equality section, <code>undefined</code> and <code>null</code> are loosely equal because both represent the absence of a value.</li>
<li><em>Does it return <code>true</code> on <code>null</code>?</em> Yes, because substituting <code>null</code> for <code>value</code> yields <code>null == null</code> which obviously returns <code>true</code>.</li>
<li><em>Does it return <code>false</code> on everything else?</em> Yes, because as we have learned from the loose equality section, <code>null</code> is not loosely equal to anything other than itself and <code>undefined</code> because the absence of a value is never considered equal to a concrete value.</li>
</ul>
<p>You may have noticed that <code>value == undefined</code> would also work for almost the same reasons. However, <code>value == null</code> is safer because the value of <code>undefined</code> is not guaranteed to stay constant. Prior to JavaScript version ES5 <code>undefined</code> could be reassigned since it’s simply a global property and even in the most recent versions of JavaScript <code>undefined</code> can be shadowed by a local variable. This could never happen with <code>null</code> because it is a literal and that makes it the objectively better choice.</p>
<p>It is worth noting that these issues with <code>undefined</code> can be avoided by using the <code>void</code> operator instead because it is guaranteed to return the expected value of <code>undefined</code>. Most commonly, the expression passed to the <code>void</code> operator for this purpose is <code>0</code> because <code>void 0</code> is short and quick to evaluate. However, I would still not recommend using <code>value == void 0</code> in place of <code>value == null</code> because it may confuse other programmers (many of which are unfamiliar with the <code>void</code> operator), <code>null</code> is two characters shorter than <code>void 0</code>, and <code>void 0</code> may be marginally slower than <code>null</code> since <code>0</code> must be evaluated before <code>undefined</code> is returned.</p>
<p>These methods work except for one lurking issue. All of our questions assume that we know for a fact that <code>value</code> has been declared and we have access to it. However, if <code>value</code> is undeclared our code will throw a <code>ReferenceError</code>. This may seem absurd because don’t we <em>always</em> know if a variable has been declared or not? Unfortunately this is not always the case.</p>
<p>Many JavaScript libraries aim to be platform agnostic. They are designed in such a way which allows them to run in the browser, on the server, or as a Node.js module. In Node.js there is a global variable <code>module</code> which can be used to export methods for use in other modules, but on the browser this variable is never declared. Therefore, if we execute <code>module == null</code> on Node.js it would return <code>false</code>, but on browsers it would throw a <code>ReferenceError</code>! One way to handle this issue would be to use <code>try</code> <code>catch</code> blocks to catch the <code>ReferenceError</code> and resume execution in the case we’re not running on Node.js:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
  value <span class="hljs-comment">// expression statement will throw a ReferenceError if value is an undeclared variable</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value is declared'</span>) <span class="hljs-comment">// will log if the previous statement did not throw an error</span>
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value is undeclared'</span>) <span class="hljs-comment">// will log if a ReferenceError was thrown</span>
}
</code></pre>
<p>Note that if any code following the first statement in the <code>try</code> block throws an error for some other reason then the <code>catch</code> block would be executed even though <code>value</code> was declared. This issue can be avoided by checking that the thrown error was specifically a <code>ReferenceError</code> using the <code>instanceof</code> operator:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
  value
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value is declared'</span>)
  <span class="hljs-comment">/* some potentially error-throwing code */</span>
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value is undeclared'</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Some other error occurred'</span>)
  }
}
</code></pre>
<p>Note that this solution only works if the potentially error-throwing code does not also throw a <code>ReferenceError</code> because it would also match the if condition. I cannot think of any reason anyone would do this on purpose. This situation would likely arise due to misspelling the name of a declared variable. For this reason you should try to keep the code in the <code>try</code> <code>catch</code> blocks as short as possible. The if condition could also be altered to check the <code>ReferenceError</code> message <code>string</code> for our specific variable <code>err instanceof ReferenceError &amp;&amp; err.message.split(' ')[0] === 'value'</code>, but I do not recommend it because it assumes your code has misspelled variables names which can and should be debugged and fixed.</p>
<p>The code with the if condition kept the same is a good solution if you specifically want to check if a variable is declared or not. However, if you want to classify undeclared variables as absent values and lump them in with <code>undefined</code> and <code>null</code> then fortunately there is a better solution. It turns out that checking the type of an undeclared variable using the <code>typeof</code> operator will not throw a <code>ReferenceError</code>, but will return the string <code>'undefined'</code> instead. This is convenient because checking the type of a declared variable with a value of <code>undefined</code> using the <code>typeof</code> operator will also return the string <code>'undefined'</code>. So the expression <code>typeof value === 'undefined'</code> also checks off the first item on our checklist! However, it doesn’t take into account if <code>value</code> is <code>null</code> so we must add an additional check in an or clause:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>)
</code></pre>
<ul>
<li><em>Does it return <code>true</code> on when <code>value</code> is undeclared?</em> Yes, because checking the type of an undeclared variable using the <code>typeof</code> operator returns the string <code>'undefined'</code> which after substituting gives us <code>'undefined' === 'undefined'</code> in the first condition which obviously returns <code>true</code>, and because the first condition is <code>true</code> the expression short-circuits and allows us to avoid the <code>ReferenceError</code> which would have been caused by <code>value === null</code>. The prevention of the error-throwing code’s execution by short-circuiting shows why the order of the two conditions cannot be switched.</li>
<li><em>Does it return <code>true</code> on <code>undefined</code>?</em> Yes, because substituting <code>undefined</code> for <code>value</code> yields <code>typeof undefined === 'undefined'</code> in the first condition, which simplifies to <code>'undefined' === 'undefined'</code> and obviously returns <code>true</code>.</li>
<li><em>Does it return <code>true</code> on <code>null</code>?</em> Yes, because although substituting <code>null</code> for <code>value</code> in the first condition fails due to <code>typeof null === 'undefined'</code> simplifying to <code>'object' === 'undefined'</code>, substituting <code>null</code> for <code>value</code> in the second condition yields <code>null === null</code> which obviously returns <code>true</code>.</li>
<li><em>Does it return <code>false</code> on everything else?</em> Yes, because checking the type of any concrete value using the <code>typeof</code> operator will not return <code>'undefined'</code> so the first condition returns <code>false</code>, and substituting any concrete value in the second condition will also return <code>false</code> because <code>null</code> is only strictly equal to itself.</li>
</ul>
<p>This method works in every situation, but it is slower than <code>value == null</code>. The optimal strategy is to use this method when you don’t know if <code>value</code> has been declared and use the previous method when you do. This is the approach taken by CoffeeScript when transpiling its <a href="https://coffeescript.org/#existential-operator" class="external-a" target="_blank" rel="noopener">existential operator</a> to JavaScript.</p>
<p>You may have noticed that a few of the expressions at the beginning of the post look almost identical to the expression we just evaluated. Interestingly enough the following four expressions share the same behavior:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value == <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> || value == <span class="hljs-literal">null</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>)
</code></pre>
<p>So why did we choose the expression with strict equality in both conditions?</p>
<ul>
<li>Strict equality is no slower than loose equality because they both check the operand types.</li>
<li>Strict equality is faster than loose equality when the types of the operands differ because it can immediately return <code>false</code> without having to coerce the operand types.</li>
<li>Loose equality often produces unexpected results and should be avoided if possible.</li>
</ul>
<p>The second bullet point makes a strong argument for using strict equality for the second condition because <code>value</code> may not be the same type as <code>null</code>, but in the first condition both <code>typeof value</code> and <code>'undefined'</code> are guaranteed to be of type <code>string</code> so the decision to use strict equality is only supported by the first and third bullet points. This makes the first expression above the best choice.</p>
<p>Lastly, let’s evaluate the rest of the expressions from the beginning of the post:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">null</span>) <span class="hljs-comment">// doesn't account for undefined</span>
<span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// doesn't account for null</span>
<span class="hljs-built_in">console</span>.log(value === <span class="hljs-literal">undefined</span> || value === <span class="hljs-literal">null</span>) <span class="hljs-comment">// works, but is simply a slower version of value == null and value == undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) <span class="hljs-comment">// doesn't account for null</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span>) <span class="hljs-comment">// doesn't account for null</span>
<span class="hljs-built_in">console</span>.log(!value) <span class="hljs-comment">// erroneously returns true for falsey values such as false, '', [], 0, etc.</span>
</code></pre>
<h2 id="object-properties">Object Properties <a class="header-anchor" href="#object-properties" aria-hidden="true">¶</a></h2>
<p>When checking for the absence of a value in an object property, additional considerations must be made regarding the property itself. Consider the following example where we use <code>value == null</code> to check for the absence of a value in each object’s <code>key</code> property:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj1 = {}
<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>
}

<span class="hljs-built_in">console</span>.log(obj1.key == <span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(obj2.key == <span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p>An object without a <code>key</code> property produces the same result as an object with its <code>key</code> property set to a value of <code>undefined</code>. This is because in contrast to undeclared variables, trying to access the value of an undeclared <em>property</em> always returns <code>undefined</code>. This means that <code>value == null</code> is a good solution if you want to classify undeclared properties as absent values and lump them in with <code>undefined</code> and <code>null</code>. However, if you specifically want to check if a property is declared or not then a different method must be used.</p>
<p>One way is to use the <code>in</code> operator:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj1 = {}
<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'key'</span> <span class="hljs-keyword">in</span> obj1) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'key'</span> <span class="hljs-keyword">in</span> obj2) <span class="hljs-comment">// true</span>
</code></pre>
<p>Note that a <code>string</code> or <code>Symbol</code> containing the property name must be used on the lefthand side of the <code>in</code> operator, not a token. This may seem like a good solution, but consider the following case:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj1 = {}
<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">constructor</span>: <span class="hljs-literal">undefined</span>
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'constructor'</span> <span class="hljs-keyword">in</span> obj1) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'constructor'</span> <span class="hljs-keyword">in</span> obj2) <span class="hljs-comment">// true</span>
</code></pre>
<p>Probably not what you expected right? The expression <code>'constructor' in obj1</code> returns <code>true</code> because the <code>constructor</code> property was inherited from the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" class="external-a" target="_blank" rel="noopener">object’s prototype chain</a>. This means that the <code>in</code> operator considers both the specific properties of the object as well as inherited properties.</p>
<p>Fortunately, there is a way to check just the specific uninherited properties of the object using the <code>hasOwnProperty</code> method, which itself is inherited from the <code>Object</code> constructor, or class in object oriented terms:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj1 = {}
<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">constructor</span>: <span class="hljs-literal">undefined</span>
}

<span class="hljs-built_in">console</span>.log(obj1.hasOwnProperty(<span class="hljs-string">'constructor'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(obj2.hasOwnProperty(<span class="hljs-string">'constructor'</span>)) <span class="hljs-comment">// true</span>
</code></pre>
<p>Note that unlike the <code>in</code> operator, the <code>hasOwnProperty</code> method can only take a <code>string</code> argument. There is one caveat to using the <code>hasOwnProperty</code> method. Consider the following case:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
}

<span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'wow'</span>)) <span class="hljs-comment">// true</span>
</code></pre>
<p>The <code>hasOwnProperty</code> method of the <code>Object</code> constructor was shadowed, or overridden in object oriented terms, by a method which always returns <code>true</code>. Accessing properties always prefers uninherited to inherited ones which is why <code>true</code> was returned for the name of an undeclared property. Fortunately there is a way around this. The <code>hasOwnProperty</code> method can be accessed directly from the <code>Object</code> constructor and called with <code>this</code> as a specified value using the <code>call</code> method of the <code>Function</code> constructor. The <code>call</code> method takes the value of <code>this</code> as its first argument and the arguments to the called function as the rest of its arguments:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="hljs-string">'wow'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<p>If you find yourself using this method more than once I would recommend extracting it out as a function:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasOwnProperty</span>(<span class="hljs-params">obj, property</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, property)
}

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
}

<span class="hljs-built_in">console</span>.log(hasOwnProperty(obj, <span class="hljs-string">'wow'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<h2 id="conclusion">Conclusion <a class="header-anchor" href="#conclusion" aria-hidden="true">¶</a></h2>
<p>To recap here are the optimal expressions.</p>
<p>Checking if a variable is declared:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
  value
  <span class="hljs-comment">// value is declared</span>
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>) {
    <span class="hljs-comment">// value is undeclared</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// some other error occurred</span>
  }
}
</code></pre>
<p>Checking for the absence of an uninherited property in an object when the object definitely doesn’t have a shadowing <code>hasOwnProperty</code> property:</p>
<pre><code class="hljs language-js">!obj.hasOwnProperty(key)
</code></pre>
<p>Checking for the existence of an uninherited property in an object when the object definitely doesn’t have a shadowing <code>hasOwnProperty</code> property:</p>
<pre><code class="hljs language-js">obj.hasOwnProperty(key)
</code></pre>
<p>Checking for the absence of an uninherited property in an object when the object may have a shadowing <code>hasOwnProperty</code> property:</p>
<pre><code class="hljs language-js">!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)
</code></pre>
<p>Checking for the existence of an uninherited property in an object when the object may have a shadowing <code>hasOwnProperty</code> property:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)
</code></pre>
<p>Checking for the absence of an inherited or uninherited property in an object:</p>
<pre><code class="hljs language-js">!(key <span class="hljs-keyword">in</span> obj)
</code></pre>
<p>Checking for the existence of an inherited or uninherited property in an object:</p>
<pre><code class="hljs language-js">key <span class="hljs-keyword">in</span> obj
</code></pre>
<p>Checking for the absence of a value when the value may be an undeclared variable:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || value === <span class="hljs-literal">null</span>
</code></pre>
<p>Checking for the existence of a value when the value may be an undeclared variable (derived using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws#Negation_of_a_disjunction" class="external-a" target="_blank" rel="noopener">De Morgan’s Law</a>):</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>
</code></pre>
<p>Checking for the absence of a value when the value is definitely declared:</p>
<pre><code class="hljs language-js">value == <span class="hljs-literal">null</span>
</code></pre>
<p>Checking for the existence of a value when the value is definitely declared:</p>
<pre><code class="hljs language-js">value != <span class="hljs-literal">null</span>
</code></pre>
<p>Checking for the absence of a value when the value is definitely declared and you want to avoid loose equality:</p>
<pre><code class="hljs language-js">value === <span class="hljs-literal">null</span> || value === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
</code></pre>
<p>Checking for the existence of a value when the value is definitely declared and you want to avoid loose equality (derived using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws#Negation_of_a_disjunction" class="external-a" target="_blank" rel="noopener">De Morgan’s Law</a>):</p>
<pre><code class="hljs language-js">value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
</code></pre>
<p>Feel free to use combinations of these to fit your needs. For example, here’s how you would check if an object has an uninherited property which has an absent value such as <code>undefined</code> or <code>null</code> when the object definitely doesn’t have a shadowing <code>hasOwnProperty</code> property:</p>
<pre><code class="hljs language-js">obj.hasOwnProperty(key) &amp;&amp; obj[key] == <span class="hljs-literal">null</span>
</code></pre>
<p>Thank you for reading!</p>

</article>
        </main>

        <footer id="site-footer">
            <span id="newer-span" style="visibility: hidden;"><a href="../../0.html">Newer</a></span>
            <div>
                <div id="tags-div"><a href="../tag/tags.html">Tags</a></div>
                <a href="../../index.html">
                    <img src="../../img/icon.png">
                </a>
                <div style="visibility: hidden;">Page 1 of 0</div>
            </div>

            <span id="older-span" style="visibility: hidden;"><a href="../../2.html">Older</a></span>
        </footer>

    </body>
</html>
